{
  "codebase_path": "/Users/mreith/Marks_Code/Merit/better-cov/merit-travelops-demo/app",
  "total_contracts": 12,
  "contracts": [
    {
      "id": "contract.api-response-schema.v1",
      "version": "1.0.0",
      "name": "TravelOps API Response Schema Validation",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Return structured travel planning response with valid JSON schema",
        "inputs": {},
        "constraints": [
          "Must be valid JSON",
          "Must include all required fields",
          "Must match Pydantic schema"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {
          "type": "object",
          "properties": {
            "assistant_message": {
              "type": "string"
            },
            "itinerary": {
              "type": "object"
            },
            "session_id": {
              "type": "string"
            }
          }
        },
        "required_fields": [
          "assistant_message",
          "itinerary",
          "session_id"
        ]
      },
      "obligations": [
        {
          "id": "OBL-001",
          "description": "Response must match TravelOpsResponse Pydantic schema",
          "applies_to": [
            "final_response"
          ],
          "rule": "pydantic_validate(response, TravelOpsResponse) == success",
          "validator": "jsonschema",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "schemas.py:63-69",
          "code_snippet": "class TravelOpsResponse(BaseModel): assistant_message: str; itinerary: dict[str, Any]; session_id: str"
        },
        {
          "id": "OBL-002",
          "description": "All three required fields must exist in response",
          "applies_to": [
            "final_response"
          ],
          "rule": "\"assistant_message\" in response and \"itinerary\" in response and \"session_id\" in response",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "postprocess.py:99-102",
          "code_snippet": "def validate_response_schema(response: dict[str, Any]) -> bool: required_fields = {\"assistant_message\", \"itinerary\", \"session_id\"}; return all(field in response for field in required_fields)"
        },
        {
          "id": "OBL-003",
          "description": "assistant_message field must be a non-empty string",
          "applies_to": [
            "final_response"
          ],
          "rule": "isinstance(response[\"assistant_message\"], str) and len(response[\"assistant_message\"]) > 0",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "schemas.py:66",
          "code_snippet": "assistant_message: str"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.itinerary-structure.v1",
      "version": "1.0.0",
      "name": "Travel Itinerary Data Structure Validation",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Ensure itinerary contains properly structured travel data",
        "inputs": {},
        "constraints": [
          "Must have destination",
          "Must have dates",
          "Must have valid structure"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {
          "type": "object",
          "properties": {
            "destination": {
              "type": "object"
            },
            "dates": {
              "type": "object"
            },
            "flights": {
              "type": "array"
            },
            "hotels": {
              "type": "array"
            },
            "activities": {
              "type": "array"
            }
          }
        },
        "required_fields": [
          "destination",
          "dates",
          "flights",
          "hotels",
          "activities"
        ]
      },
      "obligations": [
        {
          "id": "OBL-004",
          "description": "Itinerary object must validate against Itinerary Pydantic schema",
          "applies_to": [
            "final_response.itinerary"
          ],
          "rule": "pydantic_validate(itinerary, Itinerary) == success OR normalize_itinerary(itinerary) succeeds",
          "validator": "jsonschema",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "schemas.py:51-61",
          "code_snippet": "class Itinerary(BaseModel): destination: Location; dates: DateRange; flights: list[FlightInfo]; hotels: list[HotelInfo]; activities: list[Activity]; budget: float | None; notes: str | None"
        },
        {
          "id": "OBL-005",
          "description": "Destination must have city and country fields",
          "applies_to": [
            "final_response.itinerary.destination"
          ],
          "rule": "\"city\" in destination and \"country\" in destination and destination[\"city\"] and destination[\"country\"]",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "schemas.py:8-13",
          "code_snippet": "class Location(BaseModel): city: str; country: str"
        },
        {
          "id": "OBL-006",
          "description": "Dates must have start_date and end_date, no None values allowed",
          "applies_to": [
            "final_response.itinerary.dates"
          ],
          "rule": "\"start_date\" in dates and \"end_date\" in dates and dates[\"start_date\"] is not None and dates[\"end_date\"] is not None",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "postprocess.py:28-36",
          "code_snippet": "if dates.get(\"start_date\") is None: dates[\"start_date\"] = \"2024-01-01\"; if dates.get(\"end_date\") is None: dates[\"end_date\"] = \"2024-01-01\""
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.date-format.v1",
      "version": "1.0.0",
      "name": "YYYY-MM-DD Date Format Validation",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Ensure all date strings use consistent ISO format",
        "inputs": {},
        "constraints": [
          "Must be YYYY-MM-DD pattern"
        ]
      },
      "output_contract": {
        "format": "text",
        "schema_definition": {},
        "required_fields": []
      },
      "obligations": [
        {
          "id": "OBL-007",
          "description": "All date strings must match YYYY-MM-DD format",
          "applies_to": [
            "all"
          ],
          "rule": "re.match(r'^\\d{4}-\\d{2}-\\d{2}$', date_string) is not None",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "schemas.py:18-19",
          "code_snippet": "start_date: str  # YYYY-MM-DD format; end_date: str  # YYYY-MM-DD format"
        },
        {
          "id": "OBL-008",
          "description": "Flight dates must be in YYYY-MM-DD format",
          "applies_to": [
            "final_response.itinerary.flights"
          ],
          "rule": "all(re.match(r'^\\d{4}-\\d{2}-\\d{2}$', flight.get(\"date\", \"\")) for flight in flights)",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "schemas.py:27",
          "code_snippet": "date: str"
        },
        {
          "id": "OBL-009",
          "description": "Hotel check_in and check_out dates must be in YYYY-MM-DD format",
          "applies_to": [
            "final_response.itinerary.hotels"
          ],
          "rule": "all(re.match(r'^\\d{4}-\\d{2}-\\d{2}$', hotel.get(\"check_in\", \"\")) and re.match(r'^\\d{4}-\\d{2}-\\d{2}$', hotel.get(\"check_out\", \"\")) for hotel in hotels)",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "schemas.py:37-38",
          "code_snippet": "check_in: str; check_out: str"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.llm-behavior-policies.v1",
      "version": "1.0.0",
      "name": "LLM Behavioral Requirements and Policies",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Ensure LLM follows safe and accurate behavioral guidelines",
        "inputs": {},
        "constraints": [
          "Never fabricate facts",
          "Always cite sources",
          "Use provided context only"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {},
        "required_fields": []
      },
      "obligations": [
        {
          "id": "OBL-010",
          "description": "LLM must only use information from provided knowledge base, never fabricate data",
          "applies_to": [
            "all"
          ],
          "rule": "all_facts_have_knowledge_base_citations == true",
          "validator": "rubric",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "prompting.py:95",
          "code_snippet": "- Never invent facts not in the provided context"
        },
        {
          "id": "OBL-011",
          "description": "When referencing policies or facts, must cite knowledge base sources",
          "applies_to": [
            "all"
          ],
          "rule": "facts_are_cited_from_knowledge_base == true",
          "validator": "rubric",
          "enforcement": "soft",
          "severity": "major",
          "weight": 0.9,
          "code_location": "prompting.py:96",
          "code_snippet": "- Always cite knowledge base when referencing policies or facts"
        },
        {
          "id": "OBL-012",
          "description": "Must call appropriate tools for weather, availability, and real-time information",
          "applies_to": [
            "all"
          ],
          "rule": "real_time_queries_use_tools == true",
          "validator": "rubric",
          "enforcement": "soft",
          "severity": "major",
          "weight": 0.8,
          "code_location": "prompting.py:97",
          "code_snippet": "- Use tools for real-time data (weather, availability)"
        },
        {
          "id": "OBL-013",
          "description": "Must incorporate user preferences from session memory into responses",
          "applies_to": [
            "all"
          ],
          "rule": "user_preferences_respected == true",
          "validator": "rubric",
          "enforcement": "soft",
          "severity": "minor",
          "weight": 0.7,
          "code_location": "prompting.py:98",
          "code_snippet": "- Respect user preferences from session memory"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.output-format.v1",
      "version": "1.0.0",
      "name": "JSON Output Format Requirements",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Ensure LLM produces valid JSON output matching expected structure",
        "inputs": {},
        "constraints": [
          "Must be valid JSON",
          "Must match specified structure"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {},
        "required_fields": [
          "assistant_message",
          "itinerary"
        ]
      },
      "obligations": [
        {
          "id": "OBL-014",
          "description": "LLM output must be parseable as valid JSON",
          "applies_to": [
            "llm_output"
          ],
          "rule": "json.loads(llm_response[\"content\"]) succeeds without JSONDecodeError",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "postprocess.py:78-83",
          "code_snippet": "parsed = json.loads(content); assistant_message = parsed.get(\"assistant_message\", \"\"); itinerary = parsed.get(\"itinerary\", {})"
        },
        {
          "id": "OBL-015",
          "description": "JSON must contain assistant_message and itinerary top-level keys",
          "applies_to": [
            "llm_output"
          ],
          "rule": "\"assistant_message\" in parsed_json and \"itinerary\" in parsed_json",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "prompting.py:80-92",
          "code_snippet": "Always respond with valid JSON containing: {\"assistant_message\": \"...\", \"itinerary\": {...}}"
        },
        {
          "id": "OBL-016",
          "description": "Itinerary object must contain all required nested keys",
          "applies_to": [
            "llm_output.itinerary"
          ],
          "rule": "all(key in itinerary for key in [\"destination\", \"dates\", \"flights\", \"hotels\", \"activities\"])",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "prompting.py:83-91",
          "code_snippet": "\"itinerary\": {\"destination\": {...}, \"dates\": {...}, \"flights\": [], \"hotels\": [], \"activities\": [], \"budget\": null, \"notes\": \"\"}"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.config-constraints.v1",
      "version": "1.0.0",
      "name": "System Configuration and Operational Constraints",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Enforce system-level configuration boundaries",
        "inputs": {},
        "constraints": [
          "Max agent steps",
          "Temperature bounds",
          "Provider validation"
        ]
      },
      "output_contract": {
        "format": "text",
        "schema_definition": {},
        "required_fields": []
      },
      "obligations": [
        {
          "id": "OBL-017",
          "description": "Agent must stop after reaching max_agent_steps iterations",
          "applies_to": [
            "agent_execution"
          ],
          "rule": "step < config.max_agent_steps OR (step >= config.max_agent_steps AND termination_reason == \"max_steps_reached\")",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "agent.py:148-150",
          "code_snippet": "if step >= self.config.max_agent_steps: return True, \"max_steps_reached\""
        },
        {
          "id": "OBL-018",
          "description": "LLM temperature must be between 0.0 and 1.0",
          "applies_to": [
            "llm_configuration"
          ],
          "rule": "0.0 <= config.temperature <= 1.0",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "config.py:22",
          "code_snippet": "temperature: float = 0.0"
        },
        {
          "id": "OBL-019",
          "description": "LLM provider must be either 'stub' or 'openai'",
          "applies_to": [
            "llm_configuration"
          ],
          "rule": "config.llm_provider.lower() in [\"stub\", \"openai\"]",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "config.py:21",
          "code_snippet": "llm_provider: str = \"stub\"  # \"stub\" or \"openai\""
        },
        {
          "id": "OBL-020",
          "description": "When using OpenAI provider, API key must be provided",
          "applies_to": [
            "llm_configuration"
          ],
          "rule": "config.llm_provider != \"openai\" OR (config.llm_provider == \"openai\" AND config.openai_api_key is not None)",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "llm_client.py:226-227",
          "code_snippet": "if not config.openai_api_key: raise ValueError(\"OPENAI_API_KEY required when TRAVELOPS_LLM_PROVIDER=openai\")"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.flight-data.v1",
      "version": "1.0.0",
      "name": "Flight Information Data Structure",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Ensure flight data has required fields and valid structure",
        "inputs": {},
        "constraints": [
          "Must have departure/arrival",
          "Must have date",
          "Price optional but must be float"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {
          "type": "object",
          "properties": {
            "departure": {
              "type": "string"
            },
            "arrival": {
              "type": "string"
            },
            "date": {
              "type": "string"
            },
            "airline": {
              "type": [
                "string",
                "null"
              ]
            },
            "price": {
              "type": [
                "number",
                "null"
              ]
            }
          }
        },
        "required_fields": [
          "departure",
          "arrival",
          "date"
        ]
      },
      "obligations": [
        {
          "id": "OBL-021",
          "description": "Each flight must have departure, arrival, and date fields",
          "applies_to": [
            "final_response.itinerary.flights"
          ],
          "rule": "all(\"departure\" in flight and \"arrival\" in flight and \"date\" in flight for flight in flights)",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "schemas.py:22-30",
          "code_snippet": "class FlightInfo(BaseModel): departure: str; arrival: str; date: str; airline: str | None; price: float | None"
        },
        {
          "id": "OBL-022",
          "description": "If price is provided, it must be a float or None",
          "applies_to": [
            "final_response.itinerary.flights"
          ],
          "rule": "all(flight.get(\"price\") is None or isinstance(flight[\"price\"], (int, float)) for flight in flights)",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "schemas.py:29",
          "code_snippet": "price: float | None = None"
        },
        {
          "id": "OBL-023",
          "description": "departure, arrival, and date must be non-empty strings",
          "applies_to": [
            "final_response.itinerary.flights"
          ],
          "rule": "all(isinstance(flight[\"departure\"], str) and len(flight[\"departure\"]) > 0 and isinstance(flight[\"arrival\"], str) and len(flight[\"arrival\"]) > 0 and isinstance(flight[\"date\"], str) and len(flight[\"date\"]) > 0 for flight in flights)",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "schemas.py:25-27",
          "code_snippet": "departure: str; arrival: str; date: str"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.hotel-data.v1",
      "version": "1.0.0",
      "name": "Hotel Information Data Structure",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Ensure hotel data has required fields and valid structure",
        "inputs": {},
        "constraints": [
          "Must have name/location",
          "Must have check-in/check-out dates",
          "Price optional but must be float"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "location": {
              "type": "string"
            },
            "check_in": {
              "type": "string"
            },
            "check_out": {
              "type": "string"
            },
            "price_per_night": {
              "type": [
                "number",
                "null"
              ]
            }
          }
        },
        "required_fields": [
          "name",
          "location",
          "check_in",
          "check_out"
        ]
      },
      "obligations": [
        {
          "id": "OBL-024",
          "description": "Each hotel must have name, location, check_in, and check_out fields",
          "applies_to": [
            "final_response.itinerary.hotels"
          ],
          "rule": "all(\"name\" in hotel and \"location\" in hotel and \"check_in\" in hotel and \"check_out\" in hotel for hotel in hotels)",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "schemas.py:32-40",
          "code_snippet": "class HotelInfo(BaseModel): name: str; location: str; check_in: str; check_out: str; price_per_night: float | None"
        },
        {
          "id": "OBL-025",
          "description": "If price_per_night is provided, it must be a float or None",
          "applies_to": [
            "final_response.itinerary.hotels"
          ],
          "rule": "all(hotel.get(\"price_per_night\") is None or isinstance(hotel[\"price_per_night\"], (int, float)) for hotel in hotels)",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "schemas.py:39",
          "code_snippet": "price_per_night: float | None = None"
        },
        {
          "id": "OBL-026",
          "description": "name, location, check_in, and check_out must be non-empty strings",
          "applies_to": [
            "final_response.itinerary.hotels"
          ],
          "rule": "all(isinstance(hotel[\"name\"], str) and len(hotel[\"name\"]) > 0 and isinstance(hotel[\"location\"], str) and len(hotel[\"location\"]) > 0 for hotel in hotels)",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "schemas.py:35-38",
          "code_snippet": "name: str; location: str; check_in: str; check_out: str"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.activity-data.v1",
      "version": "1.0.0",
      "name": "Activity Information Data Structure",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Ensure activity data has required fields",
        "inputs": {},
        "constraints": [
          "Must have name and location"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "location": {
              "type": "string"
            },
            "date": {
              "type": [
                "string",
                "null"
              ]
            },
            "description": {
              "type": [
                "string",
                "null"
              ]
            }
          }
        },
        "required_fields": [
          "name",
          "location"
        ]
      },
      "obligations": [
        {
          "id": "OBL-027",
          "description": "Each activity must have name and location fields",
          "applies_to": [
            "final_response.itinerary.activities"
          ],
          "rule": "all(\"name\" in activity and \"location\" in activity for activity in activities)",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "schemas.py:42-49",
          "code_snippet": "class Activity(BaseModel): name: str; location: str; date: str | None; description: str | None"
        },
        {
          "id": "OBL-028",
          "description": "name and location must be non-empty strings",
          "applies_to": [
            "final_response.itinerary.activities"
          ],
          "rule": "all(isinstance(activity[\"name\"], str) and len(activity[\"name\"]) > 0 and isinstance(activity[\"location\"], str) and len(activity[\"location\"]) > 0 for activity in activities)",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "schemas.py:45-46",
          "code_snippet": "name: str; location: str"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.session-management.v1",
      "version": "1.0.0",
      "name": "Session State and Memory Management",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Maintain consistent session state across interactions",
        "inputs": {},
        "constraints": [
          "Session ID must be UUID or valid string",
          "Session data must be dict"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {},
        "required_fields": [
          "session_id"
        ]
      },
      "obligations": [
        {
          "id": "OBL-029",
          "description": "If no session_id provided, must generate valid UUID",
          "applies_to": [
            "agent_execution"
          ],
          "rule": "session_id is not None and isinstance(session_id, str) and len(session_id) > 0",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "agent.py:27-28",
          "code_snippet": "if session_id is None: session_id = str(uuid.uuid4())"
        },
        {
          "id": "OBL-030",
          "description": "Session data must be dict with preferences and history keys",
          "applies_to": [
            "session_state"
          ],
          "rule": "isinstance(session_data, dict) and \"preferences\" in session_data and \"history\" in session_data",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "state.py:14",
          "code_snippet": "session_data = _SESSION_STORE.get(session_id, {\"preferences\": {}, \"history\": []})"
        },
        {
          "id": "OBL-031",
          "description": "After each interaction, session memory must be updated with prompt and response",
          "applies_to": [
            "agent_execution"
          ],
          "rule": "config.enable_memory == false OR update_session_memory_called == true",
          "validator": "test_command",
          "enforcement": "soft",
          "severity": "minor",
          "weight": 0.6,
          "code_location": "agent.py:95-96",
          "code_snippet": "if self.config.enable_memory: update_session_memory(session_id, prompt, response.model_dump())"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.tool-execution.v1",
      "version": "1.0.0",
      "name": "Tool Call Requirements and Error Handling",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Execute tools correctly with proper error handling",
        "inputs": {},
        "constraints": [
          "Tools must be called when routing decision indicates",
          "Errors must be caught and logged"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {},
        "required_fields": []
      },
      "obligations": [
        {
          "id": "OBL-032",
          "description": "Tool execution errors must be caught and returned as error messages, not crash the system",
          "applies_to": [
            "tool_execution"
          ],
          "rule": "try_execute_tool() catches all exceptions and returns {\"tool_name\": name, \"output\": f\"Error: {str(e)}\"}",
          "validator": "test_command",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "agent.py:125-127",
          "code_snippet": "except Exception as e: results.append({\"tool_name\": tool_name, \"output\": f\"Error: {str(e)}\"})"
        },
        {
          "id": "OBL-033",
          "description": "Tool results must be list of dicts with tool_name and output keys",
          "applies_to": [
            "tool_execution"
          ],
          "rule": "all(isinstance(result, dict) and \"tool_name\" in result and \"output\" in result for result in tool_results)",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "agent.py:109",
          "code_snippet": "results.append({\"tool_name\": \"get_weather\", \"output\": str(result)})"
        },
        {
          "id": "OBL-034",
          "description": "Tools should only be executed when routing decision indicates needs_tools is true",
          "applies_to": [
            "tool_execution"
          ],
          "rule": "routing_decision.get(\"needs_tools\", False) == true OR tool_results is None",
          "validator": "test_command",
          "enforcement": "soft",
          "severity": "minor",
          "weight": 0.5,
          "code_location": "agent.py:54-55",
          "code_snippet": "if routing_decision.get(\"needs_tools\", False): tool_results = self._execute_tools(routing_decision[\"tools\"], prompt)"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.retrieval.v1",
      "version": "1.0.0",
      "name": "Knowledge Base Retrieval Requirements",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Retrieve relevant context from knowledge base when needed",
        "inputs": {},
        "constraints": [
          "Retrieval only when routing indicates",
          "Return top_k documents"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {},
        "required_fields": []
      },
      "obligations": [
        {
          "id": "OBL-035",
          "description": "Retrieval should only occur when routing decision indicates needs_retrieval is true",
          "applies_to": [
            "retrieval_execution"
          ],
          "rule": "routing_decision.get(\"needs_retrieval\", False) == true OR context_docs is None",
          "validator": "test_command",
          "enforcement": "soft",
          "severity": "minor",
          "weight": 0.5,
          "code_location": "agent.py:49-50",
          "code_snippet": "if self.config.enable_retrieval and routing_decision.get(\"needs_retrieval\", False): context_docs = retrieve(prompt)"
        },
        {
          "id": "OBL-036",
          "description": "Retrieved documents must be list of dicts with id, content, and keywords",
          "applies_to": [
            "retrieval_execution"
          ],
          "rule": "all(isinstance(doc, dict) and \"id\" in doc and \"content\" in doc and \"keywords\" in doc for doc in retrieved_docs)",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "retrieval.py:9-60",
          "code_snippet": "KB_DOCUMENTS = [{\"id\": \"visa_france\", \"content\": \"...\", \"keywords\": [\"visa\", \"france\", \"requirements\"]}, ...]"
        },
        {
          "id": "OBL-037",
          "description": "Retrieval must respect top_k parameter and return at most top_k documents",
          "applies_to": [
            "retrieval_execution"
          ],
          "rule": "len(retrieved_docs) <= top_k",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "minor",
          "weight": 1.0,
          "code_location": "retrieval.py:63",
          "code_snippet": "def retrieve(query: str, top_k: int = 3) -> list[dict[str, Any]]: ...; results = [doc for score, doc in scored_docs[:top_k]]"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    }
  ],
  "summary": "This contract discovery analysis identified 12 comprehensive contracts governing the TravelOps travel planning system. The contracts enforce strict schema validation (API responses, itinerary structure, flight/hotel/activity data), consistent date formatting (YYYY-MM-DD), LLM behavioral policies (no fact fabrication, citation requirements), configuration constraints (max steps, temperature bounds, provider validation), and operational requirements (session management, tool execution, knowledge base retrieval). The system uses Pydantic models extensively for data validation with 29 hard obligations (critical/major severity) that must pass and 8 soft obligations (quality metrics) that contribute to weighted scoring. Key findings include strong schema validation, explicit behavioral policies, robust error handling, and graceful degradation patterns. Critical contracts that must pass include API Response Schema, Itinerary Structure, Date Format, and Configuration Constraints. The accept..."
}