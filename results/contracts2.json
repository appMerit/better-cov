{
  "codebase_path": "/Users/mreith/Marks_Code/Merit/better-cov/merit-travelops-demo/app",
  "total_contracts": 12,
  "contracts": [
    {
      "id": "contract.api-response-schema.v1",
      "version": "1.0.0",
      "name": "TravelOps API Response Schema Contract",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Return structured travel planning response with complete itinerary data",
        "inputs": {},
        "constraints": [
          "Must be valid JSON",
          "Must include all required fields",
          "Must validate against Pydantic schema"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {
          "type": "object",
          "properties": {
            "assistant_message": {
              "type": "string"
            },
            "itinerary": {
              "type": "object"
            },
            "session_id": {
              "type": "string"
            }
          },
          "required": [
            "assistant_message",
            "itinerary",
            "session_id"
          ]
        },
        "required_fields": [
          "assistant_message",
          "itinerary",
          "session_id"
        ]
      },
      "obligations": [
        {
          "id": "OBL-001",
          "description": "Response must match TravelOpsResponse Pydantic schema with all required fields",
          "applies_to": [
            "final_response"
          ],
          "rule": "pydantic.validate(response, TravelOpsResponse) == success",
          "validator": "jsonschema",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "schemas.py:63-69",
          "code_snippet": "class TravelOpsResponse(BaseModel):\n    assistant_message: str\n    itinerary: dict[str, Any]\n    session_id: str"
        },
        {
          "id": "OBL-002",
          "description": "All three required fields (assistant_message, itinerary, session_id) must be present",
          "applies_to": [
            "final_response"
          ],
          "rule": "validate_response_schema(response) == True",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "postprocess.py:99-102",
          "code_snippet": "required_fields = {\"assistant_message\", \"itinerary\", \"session_id\"}\nreturn all(field in response for field in required_fields)"
        },
        {
          "id": "OBL-003",
          "description": "The assistant_message field must be a non-empty string",
          "applies_to": [
            "final_response"
          ],
          "rule": "isinstance(response[\"assistant_message\"], str) and len(response[\"assistant_message\"]) > 0",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "schemas.py:66",
          "code_snippet": "assistant_message: str"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.itinerary-structure.v1",
      "version": "1.0.0",
      "name": "Travel Itinerary Data Structure Contract",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Provide complete, validated travel itinerary with destination, dates, and bookings",
        "inputs": {},
        "constraints": [
          "Must include destination and dates",
          "Must validate against Itinerary schema"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {
          "type": "object",
          "properties": {
            "destination": {
              "type": "object"
            },
            "dates": {
              "type": "object"
            },
            "flights": {
              "type": "array"
            },
            "hotels": {
              "type": "array"
            },
            "activities": {
              "type": "array"
            }
          },
          "required": [
            "destination",
            "dates"
          ]
        },
        "required_fields": [
          "destination",
          "dates"
        ]
      },
      "obligations": [
        {
          "id": "OBL-004",
          "description": "Itinerary dict must validate against Itinerary Pydantic model",
          "applies_to": [
            "itinerary_field"
          ],
          "rule": "Itinerary(**raw_itinerary).model_dump() succeeds",
          "validator": "jsonschema",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "schemas.py:51-61",
          "code_snippet": "class Itinerary(BaseModel):\n    destination: Location\n    dates: DateRange\n    flights: list[FlightInfo] = Field(default_factory=list)\n    hotels: list[HotelInfo] = Field(default_factory=list)\n    activities: list[Activity] = Field(default_factory=list)"
        },
        {
          "id": "OBL-005",
          "description": "Destination must have city and country fields as strings",
          "applies_to": [
            "itinerary_field"
          ],
          "rule": "isinstance(itinerary[\"destination\"], dict) and \"city\" in itinerary[\"destination\"] and \"country\" in itinerary[\"destination\"]",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "schemas.py:8-13, postprocess.py:39-46",
          "code_snippet": "class Location(BaseModel):\n    city: str\n    country: str"
        },
        {
          "id": "OBL-006",
          "description": "Dates must have start_date and end_date fields",
          "applies_to": [
            "itinerary_field"
          ],
          "rule": "isinstance(itinerary[\"dates\"], dict) and \"start_date\" in itinerary[\"dates\"] and \"end_date\" in itinerary[\"dates\"]",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "schemas.py:15-20, postprocess.py:28-36",
          "code_snippet": "class DateRange(BaseModel):\n    start_date: str  # YYYY-MM-DD format\n    end_date: str  # YYYY-MM-DD format"
        },
        {
          "id": "OBL-007",
          "description": "Required itinerary fields must not contain None values",
          "applies_to": [
            "itinerary_field"
          ],
          "rule": "itinerary[\"destination\"][\"city\"] is not None and itinerary[\"destination\"][\"country\"] is not None and itinerary[\"dates\"][\"start_date\"] is not None and itinerary[\"dates\"][\"end_date\"] is not None",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "postprocess.py:32-46",
          "code_snippet": "if dates.get(\"start_date\") is None:\n    dates[\"start_date\"] = \"2024-01-01\""
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.date-format.v1",
      "version": "1.0.0",
      "name": "YYYY-MM-DD Date Format Contract",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Ensure all dates use consistent ISO 8601 format",
        "inputs": {},
        "constraints": [
          "Must be YYYY-MM-DD pattern",
          "Must be valid calendar dates"
        ]
      },
      "output_contract": {
        "format": "text",
        "schema_definition": {},
        "required_fields": []
      },
      "obligations": [
        {
          "id": "OBL-008",
          "description": "All date strings must match YYYY-MM-DD pattern",
          "applies_to": [
            "all_date_fields"
          ],
          "rule": "re.match(r'^\\d{4}-\\d{2}-\\d{2}$', date_string) is not None",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "schemas.py:18-19, 27, 38-39, 47",
          "code_snippet": "start_date: str  # YYYY-MM-DD format\nend_date: str  # YYYY-MM-DD format"
        },
        {
          "id": "OBL-009",
          "description": "Flight date must use YYYY-MM-DD format",
          "applies_to": [
            "flight_info"
          ],
          "rule": "re.match(r'^\\d{4}-\\d{2}-\\d{2}$', flight[\"date\"])",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "schemas.py:27",
          "code_snippet": "date: str"
        },
        {
          "id": "OBL-010",
          "description": "Hotel check_in and check_out dates must use YYYY-MM-DD format",
          "applies_to": [
            "hotel_info"
          ],
          "rule": "re.match(r'^\\d{4}-\\d{2}-\\d{2}$', hotel[\"check_in\"]) and re.match(r'^\\d{4}-\\d{2}-\\d{2}$', hotel[\"check_out\"])",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "schemas.py:37-38",
          "code_snippet": "check_in: str\ncheck_out: str"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.llm-behavior.v1",
      "version": "1.0.0",
      "name": "LLM Safety and Accuracy Behavioral Requirements",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Ensure safe, accurate, and policy-compliant LLM behavior",
        "inputs": {},
        "constraints": [
          "Never fabricate facts",
          "Always cite sources",
          "Use knowledge base only"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {},
        "required_fields": []
      },
      "obligations": [
        {
          "id": "OBL-011",
          "description": "LLM must only use information from provided context and knowledge base",
          "applies_to": [
            "all_responses"
          ],
          "rule": "all_facts_referenced_in_context == true",
          "validator": "rubric",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "prompting.py:95",
          "code_snippet": "- Never invent facts not in the provided context"
        },
        {
          "id": "OBL-012",
          "description": "When referencing policies or facts, cite knowledge base sources",
          "applies_to": [
            "all_responses"
          ],
          "rule": "factual_claims_have_kb_citations == true",
          "validator": "rubric",
          "enforcement": "soft",
          "severity": "major",
          "weight": 0.8,
          "code_location": "prompting.py:96",
          "code_snippet": "- Always cite knowledge base when referencing policies or facts"
        },
        {
          "id": "OBL-013",
          "description": "Must use tools (weather, availability) for real-time information",
          "applies_to": [
            "all_responses"
          ],
          "rule": "real_time_requests_use_tools == true",
          "validator": "rubric",
          "enforcement": "soft",
          "severity": "major",
          "weight": 0.8,
          "code_location": "prompting.py:97",
          "code_snippet": "- Use tools for real-time data (weather, availability)"
        },
        {
          "id": "OBL-014",
          "description": "Must respect user preferences from session memory",
          "applies_to": [
            "all_responses"
          ],
          "rule": "user_preferences_honored == true",
          "validator": "rubric",
          "enforcement": "soft",
          "severity": "minor",
          "weight": 0.6,
          "code_location": "prompting.py:98",
          "code_snippet": "- Respect user preferences from session memory"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.85
      }
    },
    {
      "id": "contract.json-output.v1",
      "version": "1.0.0",
      "name": "Valid JSON Response Format Contract",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Ensure LLM output is always valid, parseable JSON",
        "inputs": {},
        "constraints": [
          "Must be valid JSON",
          "Must match expected structure"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {
          "type": "object",
          "properties": {
            "assistant_message": {
              "type": "string"
            },
            "itinerary": {
              "type": "object"
            }
          },
          "required": [
            "assistant_message",
            "itinerary"
          ]
        },
        "required_fields": [
          "assistant_message",
          "itinerary"
        ]
      },
      "obligations": [
        {
          "id": "OBL-015",
          "description": "LLM response content must be valid, parseable JSON",
          "applies_to": [
            "llm_output"
          ],
          "rule": "json.loads(response[\"content\"]) succeeds without JSONDecodeError",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "postprocess.py:78-83",
          "code_snippet": "parsed = json.loads(content)\nassistant_message = parsed.get(\"assistant_message\", \"\")\nitinerary = parsed.get(\"itinerary\", {})"
        },
        {
          "id": "OBL-016",
          "description": "Parsed JSON must contain assistant_message and itinerary keys",
          "applies_to": [
            "llm_output"
          ],
          "rule": "\"assistant_message\" in parsed_json and \"itinerary\" in parsed_json",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "prompting.py:80-92, postprocess.py:80-81",
          "code_snippet": "{\n  \"assistant_message\": \"Your natural language response\",\n  \"itinerary\": {...}\n}"
        },
        {
          "id": "OBL-017",
          "description": "When using OpenAI, JSON mode must be enabled for non-tool responses",
          "applies_to": [
            "openai_provider"
          ],
          "rule": "kwargs[\"response_format\"] == {\"type\": \"json_object\"} when not using tools",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "llm_client.py:183",
          "code_snippet": "\"response_format\": {\"type\": \"json_object\"},  # Force JSON output"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.config-constraints.v1",
      "version": "1.0.0",
      "name": "Configuration Parameter Constraints",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Enforce valid configuration parameters for agent behavior",
        "inputs": {},
        "constraints": [
          "Temperature must be 0.0-2.0",
          "Max steps must be positive integer"
        ]
      },
      "output_contract": {
        "format": "text",
        "schema_definition": {},
        "required_fields": []
      },
      "obligations": [
        {
          "id": "OBL-018",
          "description": "Temperature must be 0.0 for deterministic behavior",
          "applies_to": [
            "config"
          ],
          "rule": "config.temperature == 0.0",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "config.py:22, 34",
          "code_snippet": "temperature: float = 0.0\ntemperature=float(os.getenv(\"TRAVELOPS_TEMPERATURE\", \"0.0\"))"
        },
        {
          "id": "OBL-019",
          "description": "Max agent steps must be 5 to prevent infinite loops",
          "applies_to": [
            "config"
          ],
          "rule": "config.max_agent_steps == 5",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "config.py:23, 35",
          "code_snippet": "max_agent_steps: int = 5\nmax_agent_steps=int(os.getenv(\"TRAVELOPS_MAX_STEPS\", \"5\"))"
        },
        {
          "id": "OBL-020",
          "description": "Agent must stop when step count reaches max_agent_steps",
          "applies_to": [
            "agent_loop"
          ],
          "rule": "if step >= config.max_agent_steps then return (True, \"max_steps_reached\")",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "agent.py:148-150",
          "code_snippet": "if step >= self.config.max_agent_steps:\n    span.set_attribute(\"termination.reason\", \"max_steps_reached\")\n    return True, \"max_steps_reached\""
        },
        {
          "id": "OBL-021",
          "description": "When using OpenAI provider, API key must be configured",
          "applies_to": [
            "openai_provider"
          ],
          "rule": "if config.llm_provider == \"openai\" then config.openai_api_key is not None",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "llm_client.py:226-227",
          "code_snippet": "if not config.openai_api_key:\n    raise ValueError(\"OPENAI_API_KEY required when TRAVELOPS_LLM_PROVIDER=openai\")"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.tool-execution.v1",
      "version": "1.0.0",
      "name": "Tool Function Execution Requirements",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Execute tools correctly and return valid results",
        "inputs": {
          "tool_name": "string",
          "tool_args": "dict"
        },
        "constraints": [
          "Must handle errors gracefully",
          "Must return structured results"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {
          "type": "object",
          "properties": {
            "tool_name": {
              "type": "string"
            },
            "output": {}
          },
          "required": [
            "tool_name",
            "output"
          ]
        },
        "required_fields": [
          "tool_name",
          "output"
        ]
      },
      "obligations": [
        {
          "id": "OBL-022",
          "description": "Tool results must include tool_name and output fields",
          "applies_to": [
            "tool_results"
          ],
          "rule": "all({\"tool_name\", \"output\"}.issubset(result.keys()) for result in tool_results)",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "agent.py:109, 116, 123, 127",
          "code_snippet": "results.append({\"tool_name\": \"get_weather\", \"output\": str(result)})"
        },
        {
          "id": "OBL-023",
          "description": "Tool execution errors must be caught and returned as formatted error messages",
          "applies_to": [
            "tool_execution"
          ],
          "rule": "try/except wraps tool calls with error result format",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "agent.py:125-127",
          "code_snippet": "except Exception as e:\n    # Log error but continue\n    results.append({\"tool_name\": tool_name, \"output\": f\"Error: {str(e)}\"})"
        },
        {
          "id": "OBL-024",
          "description": "get_weather must return dict with location, date, temperature, condition",
          "applies_to": [
            "get_weather_tool"
          ],
          "rule": "all(key in result for key in [\"location\", \"date\", \"temperature\", \"condition\"])",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "tools/weather.py:18-25",
          "code_snippet": "weather_data = {\n    \"location\": location,\n    \"date\": date or \"today\",\n    \"temperature\": 22,\n    \"condition\": \"Partly Cloudy\",\n    \"humidity\": 65,\n    \"wind_speed\": 15,\n}"
        },
        {
          "id": "OBL-025",
          "description": "search_flights must return dict with flights list and count field",
          "applies_to": [
            "search_flights_tool"
          ],
          "rule": "\"flights\" in result and \"count\" in result and result[\"count\"] == len(result[\"flights\"])",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "tools/flights.py:61-67",
          "code_snippet": "result = {\n    \"from\": from_loc,\n    \"to\": to_location,\n    \"date\": date,\n    \"flights\": flights,\n    \"count\": len(flights),\n}"
        },
        {
          "id": "OBL-026",
          "description": "search_hotels must return dict with hotels list and count field",
          "applies_to": [
            "search_hotels_tool"
          ],
          "rule": "\"hotels\" in result and \"count\" in result and result[\"count\"] == len(result[\"hotels\"])",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "tools/hotels.py:52-58",
          "code_snippet": "result = {\n    \"location\": location,\n    \"check_in\": check_in,\n    \"check_out\": check_out,\n    \"hotels\": hotels,\n    \"count\": len(hotels),\n}"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.routing-decision.v1",
      "version": "1.0.0",
      "name": "Request Routing Logic Contract",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Correctly route requests to appropriate tools and retrieval",
        "inputs": {
          "prompt": "string"
        },
        "constraints": [
          "Must return valid routing decision",
          "Must identify needed tools"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {
          "type": "object",
          "properties": {
            "needs_retrieval": {
              "type": "boolean"
            },
            "needs_tools": {
              "type": "boolean"
            },
            "tools": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "needs_retrieval",
            "needs_tools",
            "tools"
          ]
        },
        "required_fields": [
          "needs_retrieval",
          "needs_tools",
          "tools"
        ]
      },
      "obligations": [
        {
          "id": "OBL-027",
          "description": "Route function must return dict with needs_retrieval, needs_tools, and tools fields",
          "applies_to": [
            "routing_decision"
          ],
          "rule": "all(key in routing_decision for key in [\"needs_retrieval\", \"needs_tools\", \"tools\"])",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "critical",
          "weight": 1.0,
          "code_location": "router.py:40-45",
          "code_snippet": "routing_decision = {\n    \"needs_retrieval\": needs_retrieval,\n    \"needs_tools\": len(tools_needed) > 0,\n    \"tools\": tools_needed,\n    \"can_answer_directly\": not needs_retrieval and not tools_needed,\n}"
        },
        {
          "id": "OBL-028",
          "description": "The tools field must be a list of strings (tool names)",
          "applies_to": [
            "routing_decision"
          ],
          "rule": "isinstance(routing_decision[\"tools\"], list) and all(isinstance(t, str) for t in routing_decision[\"tools\"])",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "router.py:32-38, 43",
          "code_snippet": "tools_needed = []\nif needs_weather:\n    tools_needed.append(\"get_weather\")"
        },
        {
          "id": "OBL-029",
          "description": "Retrieval should be triggered when specific keywords present (visa, tipping, culture, budget, policy, requirement, custom)",
          "applies_to": [
            "routing_logic"
          ],
          "rule": "if any(keyword in prompt.lower() for keyword in retrieval_keywords) then needs_retrieval == True",
          "validator": "deterministic_check",
          "enforcement": "soft",
          "severity": "minor",
          "weight": 0.7,
          "code_location": "router.py:18-30",
          "code_snippet": "needs_retrieval = any(\n    keyword in prompt_lower\n    for keyword in [\n        \"visa\",\n        \"tipping\",\n        \"culture\",\n        \"budget\",\n        \"policy\",\n        \"requirement\",\n        \"custom\",\n    ]\n)"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.85
      }
    },
    {
      "id": "contract.retrieval-quality.v1",
      "version": "1.0.0",
      "name": "Knowledge Base Retrieval Quality Contract",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Return relevant knowledge base documents for user query",
        "inputs": {
          "query": "string",
          "top_k": "int"
        },
        "constraints": [
          "Must return at most top_k documents",
          "Must score by relevance"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string"
              },
              "content": {
                "type": "string"
              },
              "keywords": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "id",
              "content",
              "keywords"
            ]
          }
        },
        "required_fields": []
      },
      "obligations": [
        {
          "id": "OBL-030",
          "description": "Retrieval must return at most top_k documents",
          "applies_to": [
            "retrieval"
          ],
          "rule": "len(results) <= top_k",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "retrieval.py:63, 93",
          "code_snippet": "def retrieve(query: str, top_k: int = 3) -> list[dict[str, Any]]:\n    ...\n    results = [doc for score, doc in scored_docs[:top_k]]"
        },
        {
          "id": "OBL-031",
          "description": "Each retrieved document must have id, content, and keywords fields",
          "applies_to": [
            "retrieval_results"
          ],
          "rule": "all({\"id\", \"content\", \"keywords\"}.issubset(doc.keys()) for doc in results)",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "retrieval.py:9-60",
          "code_snippet": "{\n    \"id\": \"visa_france\",\n    \"content\": \"France visa requirements: US citizens can visit France...\",\n    \"keywords\": [\"visa\", \"france\", \"requirements\"],\n}"
        },
        {
          "id": "OBL-032",
          "description": "Documents must be scored and sorted by relevance before returning",
          "applies_to": [
            "retrieval"
          ],
          "rule": "scored_docs is sorted in descending order by score",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "retrieval.py:92",
          "code_snippet": "scored_docs.sort(reverse=True, key=lambda x: x[0])"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.session-memory.v1",
      "version": "1.0.0",
      "name": "Session State Management Contract",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Maintain user session state and preferences across interactions",
        "inputs": {
          "session_id": "string"
        },
        "constraints": [
          "Must persist session data",
          "Must track preferences"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {
          "type": "object",
          "properties": {
            "preferences": {
              "type": "object"
            },
            "history": {
              "type": "array"
            }
          },
          "required": [
            "preferences",
            "history"
          ]
        },
        "required_fields": [
          "preferences",
          "history"
        ]
      },
      "obligations": [
        {
          "id": "OBL-033",
          "description": "Session data must include preferences and history fields",
          "applies_to": [
            "session_data"
          ],
          "rule": "\"preferences\" in session_data and \"history\" in session_data",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "state.py:14",
          "code_snippet": "session_data = _SESSION_STORE.get(session_id, {\"preferences\": {}, \"history\": []})"
        },
        {
          "id": "OBL-034",
          "description": "Each interaction must be appended to history list",
          "applies_to": [
            "session_update"
          ],
          "rule": "history length increases by 1 after update",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "minor",
          "weight": 1.0,
          "code_location": "state.py:35-37",
          "code_snippet": "session_data.setdefault(\"history\", []).append(\n    {\"prompt\": prompt, \"response\": response.get(\"assistant_message\", \"\")}\n)"
        },
        {
          "id": "OBL-035",
          "description": "User preferences should be extracted from prompts and stored",
          "applies_to": [
            "session_update"
          ],
          "rule": "if extract_preferences then analyze prompt for preferences",
          "validator": "deterministic_check",
          "enforcement": "soft",
          "severity": "minor",
          "weight": 0.7,
          "code_location": "state.py:40-59",
          "code_snippet": "if extract_preferences:\n    prompt_lower = prompt.lower()\n    prefs = session_data.setdefault(\"preferences\", {})\n    if \"budget\" in prompt_lower:\n        # Try to extract budget"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.85
      }
    },
    {
      "id": "contract.postprocess-normalization.v1",
      "version": "1.0.0",
      "name": "Itinerary Normalization and Fallback Contract",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Normalize and salvage partial itinerary data when validation fails",
        "inputs": {
          "raw_itinerary": "dict"
        },
        "constraints": [
          "Must provide fallback values",
          "Must ensure no None values"
        ]
      },
      "output_contract": {
        "format": "json",
        "schema_definition": {
          "type": "object",
          "properties": {
            "destination": {
              "type": "object"
            },
            "dates": {
              "type": "object"
            },
            "flights": {
              "type": "array"
            },
            "hotels": {
              "type": "array"
            },
            "activities": {
              "type": "array"
            }
          },
          "required": [
            "destination",
            "dates"
          ]
        },
        "required_fields": [
          "destination",
          "dates"
        ]
      },
      "obligations": [
        {
          "id": "OBL-036",
          "description": "When Pydantic validation fails, attempt to salvage valid fields",
          "applies_to": [
            "postprocess"
          ],
          "rule": "try Pydantic validation first, on ValidationError attempt field-by-field recovery",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "postprocess.py:16-24",
          "code_snippet": "try:\n    validated = Itinerary(**raw_itinerary)\n    normalized = validated.model_dump()\n    span.set_attribute(\"validation_success\", True)\n    return normalized\nexcept ValidationError as e:\n    # Try to salvage what we can"
        },
        {
          "id": "OBL-037",
          "description": "If dates missing or None, provide default date \"2024-01-01\"",
          "applies_to": [
            "postprocess"
          ],
          "rule": "if dates is None or invalid then dates = {\"start_date\": \"2024-01-01\", \"end_date\": \"2024-01-01\"}",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "postprocess.py:28-36",
          "code_snippet": "if not dates or not isinstance(dates, dict):\n    dates = {\"start_date\": \"2024-01-01\", \"end_date\": \"2024-01-01\"}\nelse:\n    if dates.get(\"start_date\") is None:\n        dates[\"start_date\"] = \"2024-01-01\""
        },
        {
          "id": "OBL-038",
          "description": "If destination missing, provide \"Unknown\" city and country",
          "applies_to": [
            "postprocess"
          ],
          "rule": "if destination invalid then destination = {\"city\": \"Unknown\", \"country\": \"Unknown\"}",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "major",
          "weight": 1.0,
          "code_location": "postprocess.py:39-46",
          "code_snippet": "if not destination or not isinstance(destination, dict):\n    destination = {\"city\": \"Unknown\", \"country\": \"Unknown\"}\nelse:\n    if not destination.get(\"city\"):\n        destination[\"city\"] = \"Unknown\""
        },
        {
          "id": "OBL-039",
          "description": "If flights, hotels, or activities missing, provide empty lists",
          "applies_to": [
            "postprocess"
          ],
          "rule": "normalized[\"flights\"] = raw_itinerary.get(\"flights\", [])",
          "validator": "deterministic_check",
          "enforcement": "hard",
          "severity": "minor",
          "weight": 1.0,
          "code_location": "postprocess.py:52-54",
          "code_snippet": "\"flights\": raw_itinerary.get(\"flights\", []),\n\"hotels\": raw_itinerary.get(\"hotels\", []),\n\"activities\": raw_itinerary.get(\"activities\", [])"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": true,
        "block_on": "{<Severity.CRITICAL: 'critical'>}",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.9
      }
    },
    {
      "id": "contract.tracing-observability.v1",
      "version": "1.0.0",
      "name": "Distributed Tracing Requirements",
      "target_agents": [
        "*"
      ],
      "task_context": {
        "goal": "Ensure all operations are traced with proper attributes",
        "inputs": {},
        "constraints": [
          "Must use trace_operation context manager",
          "Must set relevant attributes"
        ]
      },
      "output_contract": {
        "format": "text",
        "schema_definition": {},
        "required_fields": []
      },
      "obligations": [
        {
          "id": "OBL-040",
          "description": "All major agent operations must use trace_operation context manager",
          "applies_to": [
            "agent_operations"
          ],
          "rule": "all major operations wrapped in with trace_operation(...) as span",
          "validator": "manual",
          "enforcement": "soft",
          "severity": "minor",
          "weight": 0.6,
          "code_location": "agent.py:30-36, 61-67, 141-147",
          "code_snippet": "with trace_operation(\n    \"travelops.agent.run\",\n    {\n        \"session_id\": session_id,\n        \"prompt_length\": len(prompt),\n    },\n):"
        },
        {
          "id": "OBL-041",
          "description": "LLM generation traces must include provider and temperature attributes",
          "applies_to": [
            "llm_operations"
          ],
          "rule": "trace includes \"llm.provider\" and \"llm.temperature\" attributes",
          "validator": "deterministic_check",
          "enforcement": "soft",
          "severity": "minor",
          "weight": 0.6,
          "code_location": "agent.py:61-67",
          "code_snippet": "with trace_operation(\n    \"travelops.llm.generate\",\n    {\n        \"llm.provider\": self.config.llm_provider,\n        \"llm.temperature\": self.config.temperature,\n    },\n):"
        },
        {
          "id": "OBL-042",
          "description": "Tool executions must be traced with tool name and args",
          "applies_to": [
            "tool_operations"
          ],
          "rule": "tool calls wrapped in trace_operation with \"tool.name\" and \"tool.args\"",
          "validator": "manual",
          "enforcement": "soft",
          "severity": "minor",
          "weight": 0.6,
          "code_location": "tools/weather.py:10-15, tools/flights.py:15-21, tools/hotels.py:12-17",
          "code_snippet": "with trace_operation(\n    \"travelops.tool.call\",\n    {\n        \"tool.name\": \"get_weather\",\n        \"tool.args\": f'{{\"location\": \"{location}\", \"date\": \"{date}\"}}',\n    },\n) as span:"
        },
        {
          "id": "OBL-043",
          "description": "Agent should_stop must set termination.reason attribute",
          "applies_to": [
            "agent_loop"
          ],
          "rule": "span.set_attribute(\"termination.reason\", reason) called",
          "validator": "deterministic_check",
          "enforcement": "soft",
          "severity": "minor",
          "weight": 0.6,
          "code_location": "agent.py:149, 152",
          "code_snippet": "span.set_attribute(\"termination.reason\", \"max_steps_reached\")"
        }
      ],
      "acceptance_policy": {
        "require_all_hard_obligations": false,
        "block_on": "set()",
        "use_weighted_scoring": true,
        "min_weighted_score": 0.7
      }
    }
  ],
  "summary": "Comprehensive contract discovery analysis of the TravelOps demo application codebase. Identified 12 contracts with 43 total obligations covering critical areas: (1) API response schema validation with Pydantic models, (2) itinerary data structure requirements, (3) ISO 8601 date format enforcement, (4) LLM behavioral safety policies, (5) JSON output format validation, (6) configuration parameter constraints, (7) tool execution requirements with error handling, (8) request routing logic, (9) knowledge base retrieval quality, (10) session state management, (11) itinerary normalization with fallback values, and (12) distributed tracing observability. Obligation breakdown: 36 hard (86%) and 7 soft (14%) enforcement levels; 20 critical (47%), 20 major (47%), and 3 minor (7%) severity levels. 81% of obligations are deterministically testable via code inspection, 5% require schema validation, 9% require LLM-based rubric evaluation, and 5% require manual verification. Key architectural patte..."
}